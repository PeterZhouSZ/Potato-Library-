namespace Vitelotte
{
/*!
  \page vitelotte_user_manual_page User Manual

  \authors Simon Boy√©, Gautier Ciaudo, Gael Guennebaud, Pascal Barla

  \section vitelotte_user_manual_intro Introduction

  The Vitelotte module provides tools to smoothly interpolate a set of constraints on a mesh. Its primary intent is to provide an efficient solver to create _diffusion curves images_ \cite Orzan:2008:DiffusionCurves. The diffusion solver is able to do harmonic and biharmonic interpolation on triangular meshes and output meshes with either linear or quadratic color interpolation over each face \cite Boye:2012:VectorialSolver.

  \image html vitelotte/vitelotte_overview.svg "Vitelotte takes a mesh with constraints along a curve as input (left) and produce a mesh with colors interpolated over each face (right)."

  The diffusion approach offers several advantages compared to methods currently used to produce smooth arbitrary color gradients, like Gradient Meshes. Diffusion curves do not enforce a regular topology, which allow to represent similar gradients with less control points. This lead to images easier to manipulate and more lightweight. However, diffusion curves require to solve a costly equation to produce the final image.

  Vitelotte represent images as arbitrary meshes with color interpolation over each face. This representation is easy to rasterize and scale independent, which makes it perfect to store the result of the diffusion. In facts, as our solver uses the finite element method, it also takes a mesh as input that encode the constraints and the structure of the final image.

  This approach has several advantages:

  - **Scale independence**: important features, like discontinuities, are represented exactly with curved edges while color functions are smooth at any scale. (Note: curved edges are not implemented yet, they will be in the next release.)
  - **Efficient rendering**: modern GPU excel at rendering polygons, which enable very fast rendering. We provide an OpenGL renderer for demonstration.
  - **Arbitrary dimensions**: our solver can work on surface of any dimension. So, you can just use a planar 2D mesh but also diffuse color on 3D surface meshes.
  - **Memory tradeoff**: the result of the diffusion can be a bit heavy with dense meshes. If data size matters, you may wish to store the mesh and the constraint and recompute the diffusion when required, which allow to trade CPU time for memory.

  Note that you are not constrained to diffuse colors with Vitelotte. You can also interpolate normals, displacement vectors or anything else that can be represented as a vectors.


  \section vitelotte_user_manual_about About this manual

  This user manual best read in order. The tutorial introduces some key concepts and the VGMesh page details the VGMesh class, which is central to Vitelotte. The rest of the manual does not need to be read in order, but requires a good understanding of VGMesh.


  \section vitelotte_user_manual_overview_library Library overview

  Here is a quick overview of the main elements of Vitelotte. For a more in-depth introduction, see [the tutorial](@ref vitelotte_user_manual_tutorial_page).

  At the hearth of Vitelotte is the VGMesh class. It is a mesh representation that contains per-face attributes used for color interpolation. It has been designed to be easily extensible and can support various color interpolation schemes. It can also represent a mesh with some color constraints to use as solver input.

  The FemSolver class implements a diffusion solver. It can do harmonic or biharmonic color diffusion over a VGMesh with unknown colors. It supports different kinds of elements, allowing to have either linear or quadratic color interpolation over the final image.

  The class VGMeshRenderer permits to render VGMesh with linear or quadratic color interpolation, providing basic OpenGL routines to speed-up implementation.

  MVGReader and MVGWriter work together to save and load a VGMesh in the `mvg` file format. It allows users to save meshes at any processing step (i.e., before or after a solve), which can be useful for debugging purposes.

  There are several header to include Vitelotte:
  \code
  // include VGMesh and all solver classes
  #include <Patate/vitelotte.h>

  // include VGMesh and rendering classes, see renderer documentation.
  #include <Patate/vitelotte_gl.h>

  // include VGMesh and mvg reader / writer
  #include <Patate/vitelotte_io.h>
  \endcode

  A few important features are missing in this first release. Don't worry, they are planned and should come very soon:

  - VGMesh refinement to help generating meshes with extra details around diffusion curves.
  - Curved edges for higher quality renderings, even with low resolution meshes.


  \section vitelotte_user_manual_overview_tools Tools overview

  Vitelotte also comes with a small set of tools that offer a high-level interface to the library:

  - The [mvg toolkit](@ref vitelotte_example_mvgtk_page) (`mvgtk`). Permits to do high level operations on VGMeshWithCurves. Example:
    \code{.sh}
    # poring.mvg is a mvg with diffusion curves and point gradient constraints.
    # This command generates an image with quadratic interpolation using
    # a biharmonic diffusion.
    mvgtk -v poring.mvg conv fv c2n finalize solve out out.mvg
    \endcode

    See [mvgtk's documentation](@ref vitelotte_example_mvgtk_page) for a complete explanation of this command.

  - [mvg_viewer](@ref vitelotte_example_mvg_viewer_page) is a simple OpenGL viewer. It can display both 2D images and 3D meshes.
  - [mvg_editor](@ref vitelotte_example_mvg_editor_page) is a simple editor for mvg files. Its main purpose is to allow users to experiment with the representation rather than being a user-friendly tool, so expect some rough edges.

 */
 }
