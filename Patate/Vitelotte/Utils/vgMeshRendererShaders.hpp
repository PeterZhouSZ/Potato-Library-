/*
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
// Generated by shader2cpp.
// 2015-05-04T15:46:34.276655


#ifndef _VITELOTTE_UTILS_VG_MESH_RENDERER_SHADERS_
#define _VITELOTTE_UTILS_VG_MESH_RENDERER_SHADERS_


namespace Vitelotte
{
namespace VGMeshRendererShaders
{

static const char* vert_common_glsl =
	"/*\n"
	" This Source Code Form is subject to the terms of the Mozilla Public\n"
	" License, v. 2.0. If a copy of the MPL was not distributed with this\n"
	" file, You can obtain one at http://mozilla.org/MPL/2.0/.\n"
	"*/\n"
	"\n"
	"#version 410 core\n"
	"\n"
	"uniform mat4 viewMatrix;\n"
	"\n"
	"in vec4 vx_position;\n"
	"\n"
	"out vec4 geom_position_obj;\n"
	"\n"
	"void main(void)\n"
	"{\n"
	"    gl_Position = viewMatrix * vx_position;\n"
	"    geom_position_obj = vx_position;\n"
	"}\n"
	"";

static const char* geom_common_glsl =
	"/*\n"
	" This Source Code Form is subject to the terms of the Mozilla Public\n"
	" License, v. 2.0. If a copy of the MPL was not distributed with this\n"
	" file, You can obtain one at http://mozilla.org/MPL/2.0/.\n"
	"*/\n"
	"\n"
	"#version 410 core\n"
	"\n"
	"layout(triangles) in;\n"
	"layout(triangle_strip, max_vertices = 3) out;\n"
	"\n"
	"uniform vec2 viewportSize;\n"
	"\n"
	"in vec4 geom_position_obj[];\n"
	"\n"
	"flat out int frag_index;\n"
	"out vec3 frag_linearBasis;\n"
	"out vec3 frag_position_obj;\n"
	"out vec3 frag_edgeDist_scr;\n"
	"flat out vec3 frag_vertices_obj[3];\n"
	"flat out vec3 frag_normEdges_obj[3];\n"
	"\n"
	"const vec3 basis[3] = vec3[3](\n"
	"    vec3(1, 0, 0),\n"
	"    vec3(0, 1, 0),\n"
	"    vec3(0, 0, 1)\n"
	");\n"
	"\n"
	"void main()\n"
	"{\n"
	"    vec2 position_scr[3];\n"
	"    for(int i=0; i<3; ++i)\n"
	"    {\n"
	"        position_scr[i] = (viewportSize * gl_in[i].gl_Position.xy)\n"
	"                        / (2.0 * gl_in[i].gl_Position.z);\n"
	"    }\n"
	"    float area = abs(cross(vec3(position_scr[1] - position_scr[0], 0.0),\n"
	"                           vec3(position_scr[2] - position_scr[0], 0.0)).z);\n"
	"    for(int i=0; i<3; ++i)\n"
	"    {\n"
	"        gl_Position = gl_in[i].gl_Position;\n"
	"        frag_index = gl_PrimitiveIDIn;\n"
	"        frag_linearBasis = basis[i];\n"
	"        frag_position_obj = geom_position_obj[i].xyz;\n"
	"        frag_edgeDist_scr = vec3(0.0);\n"
	"        frag_edgeDist_scr[i] = area / length(position_scr[(i+2)%3] - position_scr[(i+1)%3]);\n"
	"        for(int j=0; j<3; ++j)\n"
	"        {\n"
	"            frag_vertices_obj[j] = geom_position_obj[j].xyz;//gl_in[j].gl_Position.xy;\n"
	"            frag_normEdges_obj[j] = normalize(geom_position_obj[(j+2)%3].xyz\n"
	"                                              - geom_position_obj[(j+1)%3].xyz);\n"
	"        }\n"
	"        EmitVertex();\n"
	"    }\n"
	"}\n"
	"";

static const char* frag_common_glsl =
	"/*\n"
	" This Source Code Form is subject to the terms of the Mozilla Public\n"
	" License, v. 2.0. If a copy of the MPL was not distributed with this\n"
	" file, You can obtain one at http://mozilla.org/MPL/2.0/.\n"
	"*/\n"
	"\n"
	"#version 410 core\n"
	"\n"
	"uniform float zoom;\n"
	"uniform float pointRadius;\n"
	"uniform float halfLineWidth;\n"
	"uniform bool showWireframe;\n"
	"uniform vec4 wireframeColor;\n"
	"uniform vec4 pointColor;\n"
	"\n"
	"in vec3 frag_linearBasis;\n"
	"in vec2 position;\n"
	"flat in vec2 vertices[3];\n"
	"flat in vec2 normEdges[3];\n"
	"\n"
	"\n"
	"float irlerp(in vec3 vx, in vec3 v1, in vec3 v2)\n"
	"{\n"
	"    float alpha = acos(clamp(dot(v1, vx), -1., 1.));\n"
	"    float beta = acos(clamp(dot(v1, v2), -1., 1.));\n"
	"    return alpha / beta;\n"
	"}\n"
	"\n"
	"\n"
	"vec4 quadraticInterp(in vec4 colors[6])\n"
	"{\n"
	"    return\n"
	"        colors[0] * frag_linearBasis.x * (2. * frag_linearBasis.x - 1.) +\n"
	"        colors[1] * frag_linearBasis.y * (2. * frag_linearBasis.y - 1.) +\n"
	"        colors[2] * frag_linearBasis.z * (2. * frag_linearBasis.z - 1.) +\n"
	"        colors[3] * 4. * frag_linearBasis.y * frag_linearBasis.z +\n"
	"        colors[4] * 4. * frag_linearBasis.z * frag_linearBasis.x +\n"
	"        colors[5] * 4. * frag_linearBasis.x * frag_linearBasis.y;\n"
	"}\n"
	"";

static const char* frag_linear_glsl =
	"/*\n"
	" This Source Code Form is subject to the terms of the Mozilla Public\n"
	" License, v. 2.0. If a copy of the MPL was not distributed with this\n"
	" file, You can obtain one at http://mozilla.org/MPL/2.0/.\n"
	"*/\n"
	"\n"
	"#version 410 core\n"
	"\n"
	"uniform samplerBuffer nodes;\n"
	"uniform int baseNodeIndex;\n"
	"uniform bool singularTriangles;\n"
	"\n"
	"flat in int frag_index;\n"
	"in vec3 frag_linearBasis;\n"
	"in vec3 frag_position_obj;\n"
	"flat in vec3 frag_vertices_obj[3];\n"
	"flat in vec3 frag_normEdges_obj[3];\n"
	"\n"
	"out vec4 out_color;\n"
	"\n"
	"float irlerp(in vec3 vx, in vec3 v1, in vec3 v2);\n"
	"vec4 quadraticInterp(in vec4 colors[6]);\n"
	"\n"
	"int baseVxIndex = baseNodeIndex + frag_index * (3 + int(singularTriangles));\n"
	"\n"
	"vec4 linearInterp(in vec4 colors[3])\n"
	"{\n"
	"    return\n"
	"        colors[0] * frag_linearBasis.x +\n"
	"        colors[1] * frag_linearBasis.y +\n"
	"        colors[2] * frag_linearBasis.z;\n"
	"}\n"
	"\n"
	"void main(void)\n"
	"{\n"
	"    vec4 colorNodes[] = vec4[3](\n"
	"        texelFetch(nodes, baseVxIndex + 0),\n"
	"        texelFetch(nodes, baseVxIndex + 1),\n"
	"        texelFetch(nodes, baseVxIndex + 2)\n"
	"    );\n"
	"\n"
	"    if(singularTriangles)\n"
	"    {\n"
	"        colorNodes[0] = mix(colorNodes[0],\n"
	"                            texelFetch(nodes, baseVxIndex + 3),\n"
	"                            irlerp(normalize(frag_position_obj - frag_vertices_obj[0]),\n"
	"                                   frag_normEdges_obj[2], -frag_normEdges_obj[1]));\n"
	"    }\n"
	"\n"
	"    out_color = linearInterp(colorNodes);\n"
	"}\n"
	"";

static const char* frag_quadratic_glsl =
	"/*\n"
	" This Source Code Form is subject to the terms of the Mozilla Public\n"
	" License, v. 2.0. If a copy of the MPL was not distributed with this\n"
	" file, You can obtain one at http://mozilla.org/MPL/2.0/.\n"
	"*/\n"
	"\n"
	"#version 410 core\n"
	"\n"
	"uniform samplerBuffer nodes;\n"
    "uniform int baseNodeIndex;\n"
	"uniform bool singularTriangles;\n"
	"\n"
	"flat in int frag_index;\n"
	"in vec3 frag_linearBasis;\n"
	"in vec3 frag_position_obj;\n"
	"flat in vec3 frag_vertices_obj[3];\n"
	"flat in vec3 frag_normEdges_obj[3];\n"
	"\n"
	"out vec4 out_color;\n"
	"\n"
	"float irlerp(in vec3 vx, in vec3 v1, in vec3 v2);\n"
	"vec4 quadraticInterp(in vec4 colors[6]);\n"
	"\n"
	"int baseVxIndex = baseNodeIndex + frag_index * (6 + int(singularTriangles));\n"
	"int baseEdgeIndex = baseVxIndex + 3;\n"
	"\n"
	"void main(void)\n"
	"{\n"
	"    vec4 colorNodes[] = vec4[6](\n"
	"        texelFetch(nodes, baseVxIndex + 0),\n"
	"        texelFetch(nodes, baseVxIndex + 1),\n"
	"        texelFetch(nodes, baseVxIndex + 2),\n"
	"        texelFetch(nodes, baseEdgeIndex + 0),\n"
	"        texelFetch(nodes, baseEdgeIndex + 1),\n"
	"        texelFetch(nodes, baseEdgeIndex + 2)\n"
	"    );\n"
	"\n"
	"    if(singularTriangles)\n"
	"    {\n"
	"        colorNodes[0] = mix(\n"
	"            colorNodes[0],\n"
	"            texelFetch(nodes, baseVxIndex + 6),\n"
	"            irlerp(normalize(frag_position_obj - frag_vertices_obj[0]),\n"
	"                   frag_normEdges_obj[2], -frag_normEdges_obj[1]));\n"
	"    }\n"
	"\n"
	"    out_color = quadraticInterp(colorNodes);\n"
	"}\n"
	"";

static const char* frag_wireframe_glsl =
	"/*\n"
	" This Source Code Form is subject to the terms of the Mozilla Public\n"
	" License, v. 2.0. If a copy of the MPL was not distributed with this\n"
	" file, You can obtain one at http://mozilla.org/MPL/2.0/.\n"
	"*/\n"
	"\n"
	"#version 410 core\n"
	"\n"
	"uniform samplerBuffer nodes;\n"
	"uniform float lineWidth;\n"
	"uniform vec4 wireframeColor;\n"
	"\n"
	"in vec3 frag_edgeDist_scr;\n"
	"\n"
	"out vec4 out_color;\n"
	"\n"
	"vec3 computeEdgeDist();\n"
	"int minIndex(in vec3 dist);\n"
	"float interpFactor(float dist, float radius);\n"
	"\n"
	"void main(void)\n"
	"{\n"
	"    float alpha = smoothstep(\n"
	"        -0.5, 0.5,\n"
	"        lineWidth / 2.0 - min(frag_edgeDist_scr.x,\n"
	"                              min(frag_edgeDist_scr.y,\n"
	"                                  frag_edgeDist_scr.z)));\n"
	"    if(alpha < 0.001)\n"
	"        discard;\n"
	"\n"
	"    out_color = vec4(wireframeColor.rgb, wireframeColor.a * alpha);\n"
	"}\n"
	"";

}
}

#endif
