/*
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/


namespace Vitelotte {

/*!
  \page vitelotte_user_manual_fem_solver_page The FEM Solver

  \section vitelotte_user_manual_fem_solver_intro_sec Introduction

  FemSolver allow to diffuse values (colors, ...) directly on a VGMesh using the finite element method (FEM). This is a simple way to get smooth color gradients from a sparse set of constraints.

  Vitelotte currently support two kind of diffusions, with their advantages and drawbacks:

  - **Harmonic** diffusion satisfy the equation

    \f[ \Delta f = 0 \f]

    in such a way that it interpolates constraints (nodes with a value set). This equation can be solved using very simple elements. Vitelotte currently supports linear and quadratic triangular elements for this, which uses the same interpolation function than rendering.

    However, harmonic interpolation has some drawbacks. It does not allow to have \f$C^1\f$ transitions across constraint, which limit its usefulness in much cases. For instance, to represent smooth shading, biharmonic diffusion produce better results.

  - **Bi-harmonic** diffusion satisfy a similar equation

    \f[ \Delta^2 f = 0 \f]

    Theoretically, solving this equation using FEM requires \f$C^1\f$ continuity across the elements, which in turn requires using high order elements. As this is unpractical, we use _non-conforming_ elements that do not meet this requirement but allow convergence nonetheless: Morley elements and Fraeijs de Veubeke's elements (FV). They are similar to linear and quadratic elements respectively, but add a derivative node over each edge. As these elements are not even \f$C^0\f$ on their boundaries, we just discard the derivative node for rendering and use the classical linear and quadratic element.

    Bi-harmonic diffusion is a bit more costly, but also offers smoother gradients and more control. For instance, it is possible to constraint derivative nodes to add control over gradients. The main problem of bi-harmonic diffusion is that it extrapolate: it can produce values higher or lower than constraints. When diffusing colors, it means that you can have color component below 0 and above the maximum, which may lead to artifacts.


  \section vitelotte_user_manual_fem_solver_usage_sec Using the solver

  Using the solver is quite easy. You first need to create the solver. FemSolver takes two template parameters: a VGMesh type and an ElementBuilder. Available element builders are:

  - **LinearElementBuilder** solve harmonic diffusion over linear element. Input mesh must have the TO_VERTEX_VALUE attribute enabled.
  - **QuadraticElementBuilder** solve harmonic diffusion over quadratic element. Input mesh must have the TO_VERTEX_VALUE and EDGE_VALUE attributes enabled.
  - **MorleyElementBuilder** solve biharmonic diffusion using Morley elements. Input mesh must have TO_VERTEX_VALUE and EDGE_GRADIENT attributes enabled.
  - **FVElementBuilder** solve biharmonic diffusion using FV elements. Input mesh must have TO_VERTEX_VALUE, EDGE_VALUE and EDGE_GRADIENT attributes enabled.

  These element builder does not support singularities (in practice, the attachment point FROM_VERTEX_VALUE is ignored). To enable it, you must wrap your element builder into a SingularElementDecorator. This only support up to one singularity by element, so it may be necessary to refine the input mesh to ensure this.

  There is a typical example:

  \code{.cpp}
  typedef VGMesh<float, /*...*/> Mesh;

  typedef FVElementBuilder<Mesh, double> FVBuilder;
  typedef SingularElementDecorator<FVBuilder> ElementBuilder;
  typedef FemSolver<Mesh, ElementBuilder> Solver;
  \endcode

  Note that the element builder are parametrized by a scalar type. It will be used internally by the solver instead of the mesh Scalar type. This may be used to avoid numerical problems. In our example, we always use floats for meshes and double in the solver, as above.

  All is left to do is to create a solver and solve the problem:

  \code
  Mesh mesh;
  // [ Fill the mesh... ]

  Solver solver(&mesh);
  solver.build();
  solver.solve();
  \endcode

  FemSolver::build() build the internal matrices and compute factorizations. It does not depend on constraint values, so if you are using the solver in an interactive application (like our `mvg_editor` example), it is not always necessary to call it. FemSolver::solve() effectively solve the diffusion and set a value to each unknown nodes of `mesh`.

  The solver may fail, either because input is invalid or because of numerical instability. We try to detect errors and to provide meaningful messages in case of problem:

  \code
  SolverError::Status status = solver.error().status();
  if(status != SolverError::STATUS_OK) {
    cout << ((status == SolverError::STATUS_ERROR)? "Error: ": "Warning: ")
         << solver.error().message() << endl;
  }
  \endcode


  \section vitelotte_user_manual_fem_solver_extending_sec FemSolver internal and extending FemSolver

  - TODO


 */

 }
