/*
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

namespace Vitelotte {

/*!
  \page vitelotte_user_manual_vg_mesh_page The VGMesh class

  \section vitelotte_user_manual_vg_mesh_introduction_sec Introduction

  VGMesh is the heart of Vitelotte: it is both the class that represent mesh-based vector images and the class used as input of the solver.

  VGMesh inherit PatateCommon::SurfaceMesh, which is adapted from the [Surface_mesh](http://opensource.cit-ec.de/projects/surface_mesh) library. Note that SurfaceMesh is in the namespace PatateCommon because it might be useful for other patates in the future. We will not enter in detail about how to manipulate SurfaceMesh objects here so don't hesitate to consult the references. This is an halfedge-based data structure, so if you are familiar with this using it should be quite straightforward.

  There is a few things to know about surface mesh. First, surface mesh allow to add arbitrary properties to any kind of element. For instance, vertices coordinates are just a vertex property of vectors. Secondly, mesh's elements (vertices, faces, ...) are manipulated through _handles_. These handle are really just indices that allow to find elements inside the property arrays. So to access the coordinate of some vertex, you need a handle to that vertex and the "position" vertex property. In practice, standard property are accessible directly from the mesh, so you end up with this kind of code:

  \code{.cpp}
  Vertex vx = /*...*/; // Some vertex
  // Get the outgoing halfedge associated with vx
  Halfedge h = mesh.halfedge(vx);
  // Set the coordinate of the target vertex of h
  mesh.position(mesh.toVertex(h)) = Vector(1., 2.);
  \endcode


  \section vitelotte_user_manual_vg_mesh_dims_coeffs_sec Dimensions and coefficients

  VGMesh allow to customize the type of coordinates and the type of values (we use the term value instead of color as a VGMesh can be used to store colors, normals, heights or anything else) through template parameters. The first parameter is the underlying scalar type (typically `float` or `double`). The two other set respectively the number of dimension of coordinates and the number of coefficients per value. Setting these values at compile time is not always practical, so you can use the special value Vitelotte::Dynamic which allow to set them a run time:

  \code
  // Declare a Mesh type with dynamic dimensions and values.
  typedef VGMesh<float, Dynamic, Dynamic> Mesh;
  // Create a 3D mesh with 4 coefficients per value (maybe rgba colors).
  Mesh mesh(3, 4);
  // [...]
  // Modify the number of dimensions / coefficients later:
  mesh.setNDims(2);
  mesh.setNCoeffs(1);
  \endcode


  \section vitelotte_user_manual_vg_mesh_nodes_sec Nodes

  VGMesh has the concept of _node_. As explained in [the tutorial](@ref vitelotte_user_manual_tutorial_page), a node define a value on the mesh. A single node can be referenced by several _attachment points_, typically all halfedge around a vertex reference the same node unless the vertex lie on a discontinuity. Finally, nodes work like surface mesh's elements: they are just handles and you can define your own properties.

  There is currently 4 attachment points supported by VGMesh (more can be added with properties). All of them are defined by halfedge:

  \image html vitelotte/vgmesh_attributes.svg "VGMesh's attachment points."

  - VGMesh::TO_VERTEX_VALUE: represent the value at the \e target vertex of an halfedge.
  - VGMesh::FROM_VERTEX_VALUE: represent the value at the \e source vertex of an halfedge.
  - VGMesh::EDGE_VALUE: represent the value on an halfedge (typically, on the midpoint).
  - VGMesh::EDGE_GRADIENT: represent the orthogonal \e derivative on an halfedge. Depending on the interpolation function, it can be the derivative at the midpoint (morley) or the average derivative over the edge (FV). The direction of the derivative depends on the halfedge orientation: if VGMesh::halfedgeOrientation() is true, it is the derivative inward, else the derivative outward.

  Before using one of these attachment points, you must enable the corresponding mesh _attribute_. For instance, to use quadratic interpolation (all of the above attachment point except EDGE_GRADIENT), you can do:

  \code
  mesh.setAttributes(  Mesh::TO_VERTEX_VALUE_FLAG
                     | Mesh::FROM_VERTEX_VALUE_FLAG
                     | Mesh::EDGE_VALUE_FLAG)

  // Or, alternatively
  mesh.setAttributes(Mesh::QUADRATIC_FLAGS)
  \endcode

  Then, you can get/set nodes this way:

  \code
  Halfedge h = /*...*/;                   // Some halfedge
  Node n = mesh.addNode(Value(/*...*/));  // Add a new node
  mesh.fromVertexValueNode(h) = n;
  mesh.toVertexValueNode(h)   = n;
  mesh.edgeValueNode(h)       = n;
  mesh.edgeGradientNode(h)    = n;

  // Alternative methods:
  mesh.halfedgeNode(h, Mesh::TO_VERTEX_VALUE) = n;

  // Access to the opposite node (i.e. the node directly on the other side of the edge):
  mesh.halfedgeOppositeNode(h, Mesh::TO_VERTEX_VALUE) = n;
  \endcode

  There is two value node per vertex per triangle. This allow to represent singularities: points that emit a different color in different direction, like the apex of a conical gradient:

  \image html vitelotte/singularities.png "The two extremities of the curve are singularities."

  When used with a solver, nodes can have the special value "unknown" (returned by VGMesh::unknownValue()). This allow to mark nodes that the solver has to compute. Known nodes thus behave as constraints the solver must satisfy. There is an illustration of an input to the solver (for simplicity, when two opposite nodes on an edge are the same, they are merged):

  \image html vitelotte/nodes.svg "A typical input to the solver. White dots are unknown nodes an orange ones are constraints."

  There is no direct way to delete a node. The only be done with VGMesh::deleteUnusedNode() that scan the whole mesh and mark all unused nodes fore deletion. The rational behind this is that we can not check if a node is used efficiently on deletion, so deleting a node could result in an invalid mesh.


  \section vitelotte_user_manual_vg_mesh_nodes_manipulation_sec High-level node manipulation

  To ease the assignment of nodes around vertices, we provide the following functions:

  \code
  // `n0` and `n1` are nodes and `h0` and `h1` are two halfedge with the same
  // _from_ vertex `vx`.

  // Set nodes adjacent to vx in the arc [h0, h1[ to n0.
  mesh.setVertexNode(n0, h0, h1);

  // Set nodes adjacent to vx in the arc [h0, h1[ to values interpolated
  // from the value of n0 (in the direction of h0) to the value of n1
  // in the direction of h1).
  mesh.setSingularity(n0, n1, h0, h1);
  \endcode


  \subsection vitelotte_user_manual_vg_mesh_finalize_subsec The finalize method

  When preparing the input of the solver, setting all nodes for each attachment point by hand can be tedious. We provide the method VGMesh::finalize() that takes a mesh with a few constraints set and "guess" all the missing one using heuristics.

  For edge nodes (EDGE_VALUE and EDGE_GRADIENT), the algorithm is straighforward. For each edge:

  - If both opposite nodes are invalid, a new unknown node is added an set on both side.
  - If one side is linked to the node `n` and the other is invalid, it is set to `n` too.
  - If both nodes are valid, nothing is done.

  In other words, to create a discontinuity both sides of the edge must be constrained. Else the edge is set to be smooth.

  Vertices nodes (TO_VERTEX_VALUE and FROM_VERTEX_VALUE) are a bit more complicated. It first cycle through all edges to create a list of constrained edges. For each edges around each vertices, it apply the following rules:

  - If both sides have different nodes constrained to the same value, they are merged (one is discarded).
  - If both sides have invalid nodes, or one is invalid and the other is an unknown, or both are the _same_ unknown node, then both sides are discarded.
  - If one side is constrained and the other invalid, the constrained node is set on both side.
  - Else there is two different nodes on each sides and nothing is done.

  In the end, either both sides of the edge are valid or none. Edges are added to the constraint list if they are linked to valid nodes. If there is no constraint around a vertex, a new unknown node is added and both sides of an edge are set to it to create one. Now every arcs (halfedges between two constrained edges) are handled separately. Note that the first and last halfedges have a node set and not the others. This lead to:

  - If both extremities are the same, all halfedges of the arc are set to it.
  - If both nodes are different unknowns, one is discarded and all halfedges of the arc are set to the other. This mean that we disallow singularity here. It makes sense because the solver would try very hard to set the same value on all nodes here. Avoiding a singularity reduces the number of node and make the solver faster.
  - If one node is unknown and the other is constrained, all halfedges of the arc are set to the constraint node and the unknown is discarded for the same reason as above.
  - If both nodes are constraints with different values, we call VGMesh::setSingularity.

  \warning This algorithm is not perfect. As it does simplifications (mainly replacing unknown nodes by others) it may not produce the intended result in case of non-local constraints (when a same unknown node is used on different places on the mesh).


  \subsection vitelotte_user_manual_vg_mesh_simplify_subsec The simplify method

  The VGMesh::simplify() method is basically the reverse of finalize. It tries to remove as much nodes as possible in such a way that VGMesh::finalize would rebuild the same problem. It is useful to reduce the size of files containing pre-solve meshes.

  \warning As finalize, this algorithm may lead to unexpected results in case of non-local constraints.

  ############ Tutorial stuff

  Vitelotte allow to manipulate vectorial images represented by meshes. More specifically, the image is partitioned in cells (we will call them "faces") and each cell use some mathematical function to describe its color. A simple example would be to a triangular mesh with a face-wise linear color interpolation of the color defined for each vertex. However, we are not limited to this: linear interpolation is often not enough to produce visually smooth results, so most of the time we will use quadratic interpolation.

  Vitelotte uses the class VGMesh to represent images. Like the rest of the Patate lib, VGMesh is templated. Its parameters are a scalar type, the number of dimensions \f$d\f$ of the mesh and the number of coefficients \f$n\f$ (aka. the number of channels). This mean that in practice VGMesh can represent a function \f$f: \Re^2 \rightarrow \Re^n\f$ embedded on a surface of dimension \f$d\f$. It may not be practical to have these values fixed at compile time, so we can also ask to be able to change them at runtime by using the symbolic value Dynamic. Let's use a typedef to ease our life:

  \snippet Vitelotte/tutorial/tutorial.cpp Declare the Mesh class

  As we set Dynamic as the number of dimensions and coefficients, we have to choose these values at runtime. The default constructor of VGMesh set them to 0, which is not what we want. Hopefully, there is an other constructor taking these value as parameters. We will use 3 channels to represent RGB images. For now, we will set the number of dimensions to 3, because the obj loader can only load meshes of dimension 3. We will change that value later. We also set the mesh's attribute on construction, but we will talk about this later.

  \snippet Vitelotte/tutorial/tutorial.cpp Create the mesh

  Now, we want to load a mesh defined in an `obj` file. In practice, VGMesh inherits PatateCommon::SurfaceMesh, a generic mesh representation copied from the [Surface_mesh](http://opensource.cit-ec.de/projects/surface_mesh) library (with some modifications). This class comes with an other template class PatateCommon::OBJReader that allow to read `obj` file. In practice, we can use it directly to load our VGMesh like this:

  \snippet Vitelotte/tutorial/tutorial.cpp Load a .obj

  You might wonder why we need to create a temporary reader object. This can have several use. One of them is that it allow to customize error reporting: by default it prints error on `stderr` and ignore warnings, but you can set your own callbacks. An other is that you can use the same reader for several files to avoid to reallocate some internal buffers. Other readers like the MVGReader use the same principle.

  We assume that the obj file we just loaded contains only vertices on the x-y plane, so we will discard the z coordinate. This result in a 2D image. This is simply done by changing the number of dimensions of the mesh with VGMesh::setNDims(). Note that this function is dumb: if you reduce the number of dimensions it will just discard extra coordinates, and if you increase it new coordinates _will not be initialized_.

  \snippet Vitelotte/tutorial/tutorial.cpp Convert the mesh in 2D


  \subsection vitelotte_user_manual_tutorial_vg_mesh_attributes_subsec Attributes

  To produce an image, we need to describe the color inside each face with some mathematical function. VGMesh is designed to be independent of the function used, so evaluating them is the job of some other class. VGMesh just need to store an arbitrary  set of parameters required to evaluate the function.

  As VGMesh inherits PatateCommon::SurfaceMesh, it allow to define arbitrary properties on vertices, edges, halfedges or faces. However this is not very practical so we provide a higher-level interface. VGMesh allow to choose a set of attributes describing which parameters we need per face. You can think of attributes as "attachment points" where you can define parameter on the faces. The currently available attributes are:

  - VGMesh::TO_VERTEX_VALUE: The color value at the target vertex of an halfedge.
  - VGMesh::FROM_VERTEX_VALUE: The color value at the source vertex of an halfedge.
  - VGMesh::EDGE_VALUE: The color value at the middle point of an halfedge.
  - VGMesh::EDGE_GRADIENT: The color _derivative_ in the normal direction of an halfedge.

  This may be a bit abstract, so there is an illustration:

  \image html vitelotte/vgmesh_attributes.svg "VGMesh's attributes."

  For example, with just the VGMesh::TO_VERTEX_VALUE attribute we have one color per vertex per face. This is enough to do linear color interpolation over each face.

  You can notice that there are two attributes per vertex. This allow to represent singularities, where two different colors are set on the same point, but in different directions.

  \image html vitelotte/singularities.png "The two extremities of the curve are singularities."

  With value attributes on the vertices and in the middle of each edge, we can do quadratic interpolation over each face. Our experience show that quadratic interpolation allow much better visual quality than linear interpolation, so unless said otherwise, all the illustrations are using it.

  The VGMesh::EDGE_GRADIENT is a bit more tricky. It is in fact unused for rendering: its purpose is to allow our FEM solver to use special elements for biharmonic diffusion. In practice, we will use Fraeijs de Veubeke's elements (FV) which happen to need exactly all the attributes of VGMesh.

  Attributes you want to use must be enabled. This way, unused attribute does not consume memory. This can be done with the method VGMesh::setAttribute or directly in the constructor. Remember our call to VGMesh's constructor ?

  \snippet Vitelotte/tutorial/tutorial.cpp Create the mesh

  The VGMesh::FV_FLAGS constant simply mean that we want to enable the attributes required for FV elements.


  \subsection vitelotte_user_manual_tutorial_vg_mesh_nodes_subsec Nodes

  So our VGMesh object has a whole set of attribute enabled. How do we access them ? Well, there is a level of indirection: we do not store a value (this is our term for color) directly for each attribute. Instead, we store a "node". Each node as a value, so this is almost the same. The difference is that a single node can be referenced by several attachment points. For instance, unless you want to represent a discontinuity, all attachments points around a vertex will likely point to the same node.

  This has several uses. Nodes can have an unknown value. This basically mean that we don't know yet which color should go here. Finding the value of such nodes is indeed the job of the solver. Now, having several attachment points pointing to the same node has a semantic meaning: it tells the solver that we want the same color at all these attachment points. Attaching unknowns and constraints nodes wisely is the key to control the solver. There is a typical example:

  \image html vitelotte/nodes.svg "A typical input to the solver. White dots are unknown nodes an orange ones are constraints."

  For simplicity, we don't show gradient nodes and we merge nodes on both sides of an edge if they are the same.

  We can define discontinuities simply by having a different node on each side of an edge. In the above example, the bottom left side is constrained while the top right is left unknown (The blue color comes from other constraints outside the boundary of the picture), but we could have constrained both sides or left them unknown too. When we want continuity, we simply link both side of the edge to the same nodes.

  What is going on if we use the same unknown node at two (or more) different places on the mesh ? Well, we call this _non-local constraints_. The current implementation of the solver supports it, but you need to pass a special flag to enable it as it as a small impact on performances.

  So, let's manipulate some node. By default, all attachment points are linked to an invalid node. This is not good: the solver will fail if the input mesh has invalid nodes, and the renderer will display an arbitrary color (likely black). We will start simple and create a node for each vertex and each edge, assign them random colors and link them to the corresponding attachment point. This gives us:

  \snippet Vitelotte/tutorial/tutorial.cpp Assign random colors

  There is two ways to access nodes. In the vertex loop, we use VGMesh::halfedgeNode and VGMesh::halfedgeOppositeNode. They take an halfedge and an attribute as parameter, which is practical in this case, particularly to set the opposite node. There is also more direct functions like VGMesh::edgeValueNode that we use in the edge loop. Such functions are defined for all the attributes.


  \subsection vitelotte_user_manual_tutorial_vg_mesh_output_subsec Writing mvg

  Well, let's output what we have now, we will look into the solver later. We developed a file format suitable to store VGMeshes that supports arbitrary attributes, unknown nodes and invalid nodes. It allow us to store meshes at different processing step, which is useful for debugging or to share intermediary results.

  We will not describe the format here, it has its own page. Just know that it is a simple text-based format inspired from the obj mesh format.

  Saving is straightforward and really similar to the code to read the mesh:

  \snippet Vitelotte/tutorial/tutorial.cpp Write the mesh

  We change the attributes to VGMesh::QUADRATIC_FLAGS to discard VGMesh::EDGE_GRADIENT which is useless for rendering. This allow to reduce slightly the output size. There is the result on a simple grid mesh:

  \image html vitelotte/tutorial_random.png "A regular grid with random colors."

  Well, that's ugly. We surely can do better using the solver.


  \subsection vitelotte_user_manual_tutorial_solver_subsec Using the solver

  The first thing to do to use the solver is to prepare the input. We likely want to set a few constraints and have something smooth everywhere else. As it may be annoying to do it by hand, we provide the VGMesh::finalize method that do this more or less automatically.

  Before we call VGMesh::finalize, we need to set a few constraints. Here, we will just set a constrained node for some random vertices and finalize will automatically propagate this node all around the constrained vertices. We could also set a different unknown node on each side of a path to insert a discontinuity.

  \snippet Vitelotte/tutorial/tutorial.cpp Color dots and finalize

  If we output the mesh now, we will have a black image with a few colored points. This is because our viewer shows unknown nodes as black.

  \image html vitelotte/tutorial_finalized.png "The mesh after finalization."

  Remember that the algorithm of finalize is not perfect and does not handle all tricky cases. For instance, it is not guaranteed to work for non-local constraints. See the documentation for details.


 */

 }
