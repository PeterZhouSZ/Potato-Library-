/*
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

namespace Vitelotte {

/*!
  \page vitelotte_user_manual_vg_mesh_page The VGMesh class

  \section vitelotte_user_manual_vg_mesh_introduction_sec Introduction

  VGMesh is the heart of Vitelotte: it is both the class that represent mesh-based vector images and the class used as input of the solver.

  VGMesh inherit PatateCommon::SurfaceMesh, which is adapted from the [Surface_mesh](http://opensource.cit-ec.de/projects/surface_mesh) library. Note that this class is in the namespace PatateCommon because it might be useful for other patates in the future. We will not enter in detail about how to manipulate SurfaceMesh objects here so don't hesitate to consult the references. This is an halfedge-based data structure, so if you are familiar with this using it should be quite straightforward.

  There is a few things to know about surface mesh. First, surface mesh allow to add arbitrary properties to a kind of element. For instance, vertices coordinates are just a property containing vectors. Secondly, mesh's elements (vertices, faces, ...) are manipulated through _handles_. These handle are really just indices that allow to find elements inside the property arrays. So to access the coordinate of some vertex, you need a handle to that vertex and the "position" vertex property. In practice, standard property are accessible directly from the mesh, so to get the outgoing halfedge associated with some vertex, just type something like

  \code
  Vertex vx = ...;
  Halfedge h = mesh.halfedge(h);
  \endcode

  VGMesh add the concept of _node_. As explained in [the tutorial](@ref vitelotte_user_manual_tutorial_page), a node define a color on the mesh (we prefer the term _value_, as vitelotte can be used to diffuse something else than color). A single node can be referenced by several _attachment points_, typically all halfedge around a vertex reference the same node unless the vertex lie on a discontinuity. Finally, nodes work like surface mesh's elements: they are just handles and you can define your own properties.

  - VGMesh is the hearth of Vitelotte: it is the input and the output of all Vitelotte's operations.
  - It is more or less like a mesh with linear color interpolation on each face, except that the interpolation is not necessarily linear and that we are not restricted to interpolate colors.
  - Flexibility: template params that can also be dynamic, just like Eigen matrices.
  - Inherit from Surface_mesh (make a page to document differences / update SurfaceMesh doc)


  \section vitelotte_user_manual_vg_mesh_attributes_and_nodes_sec Attributes and Nodes

  - Values are not stored directly in faces, but rather in nodes that are referenced by the face. This allow one node to be used by several faces, which is a very important semantic information used by the solver.
  - Nodes can have a special value "unknown". If a mesh posses such node, the real can be computed using a solver. This is how we define the input of the FEM solver.
  - VGMesh does not care about what interpolation is used, it just store values/gradients at specific points on each faces.
  - Each face reference a set of nodes associated with some semantic. For instance, to use quadratic interpolation with singularities, the mesh should store two nodes per vertex per face (one for each edge) plus one node per edge. These "attachment points" are called attributes. Which attribute is active on a given mesh can be controlled by calling VGMesh::setAttirbutes().
  - Attributes may (and by default does) reference invalid nodes. Using Vitelotte is mainly about setting up the nodes correctly (don't worry, we have tools to help).
  - Available attributes are:
    + VGMesh::TO_VERTEX_VALUE : represent the value at the \e target vertex of an halfedge.
    + VGMesh::FROM_VERTEX_VALUE : represent the value at the \e source vertex of an halfedge.
    + VGMesh::EDGE_VALUE : represent the value on an halfedge (typically, on the midpoint).
    + VGMesh::EDGE_GRADIENT : represent the orthogonal \e derivative on an halfedge. Depending on the interpolation function, it can be the derivative on the midpoint (morley) or the average derivative over the edge (FV). The direction of the derivative depends on the halfedge orientation: if VGMesh::halfedgeOrientation() is true, it is the derivative inward, else the derivative outward.


  \section vitelotte_user_manual_vg_mesh_nodes_manipulation_sec Nodes Manipulation

  - Adding nodes is done with VGMesh::addNode(). Without parameter it add an unknown node, otherwise it add a node with the specified value.
  - There is no direct way to remove node, as a node can be used somewhere and it is costly to detect where. The solution is to use VGMesh::deleteUnusedNodes() which mark all unused nodes for deletion. Note that the actual deletion is done by VGMesh::garbageCollection(), but deleted node are skipped by the NodeIterator.
  - Nodes can be set manually by face using VGMesh::halfedgeNode(), VGMesh::halfedgeOppositeNode() or any method like VGMesh::toVertexValueNode().
  - As we generally want to set the same node all around a vertex (or on an arc around a vertex), we provide the method VGMesh::setVertexNode() to facilitate this case.
  - There is also VGMesh::setSingularity() which is very similar to VGMesh::setVertexNode() except that it set a singularity given two nodes with different values. It add as many node as necessary to create a radial gradient.
  - When creating a mesh to feed the solver, most of the vertex and edges are connected to their respective unknown node, which means that there is no specific constraint here and no discontinuity. The method VGMesh::finalize() allow to do this automatically. For vertices and edges where with a few nodes set, it rely on some heuristics (describe the heuristics).
  - Finally, there is a VGMesh::simplify() try to remove all nodes that could be recreated by VGMesh::finalize(). It can be useful to reduce the size of files storing VGMeshes before solve.

  ############ Tutorial stuff

  Vitelotte allow to manipulate vectorial images represented by meshes. More specifically, the image is partitioned in cells (we will call them "faces") and each cell use some mathematical function to describe its color. A simple example would be to a triangular mesh with a face-wise linear color interpolation of the color defined for each vertex. However, we are not limited to this: linear interpolation is often not enough to produce visually smooth results, so most of the time we will use quadratic interpolation.

  Vitelotte uses the class VGMesh to represent images. Like the rest of the Patate lib, VGMesh is templated. Its parameters are a scalar type, the number of dimensions \f$d\f$ of the mesh and the number of coefficients \f$n\f$ (aka. the number of channels). This mean that in practice VGMesh can represent a function \f$f: \Re^2 \rightarrow \Re^n\f$ embedded on a surface of dimension \f$d\f$. It may not be practical to have these values fixed at compile time, so we can also ask to be able to change them at runtime by using the symbolic value Dynamic. Let's use a typedef to ease our life:

  \snippet Vitelotte/tutorial/tutorial.cpp Declare the Mesh class

  As we set Dynamic as the number of dimensions and coefficients, we have to choose these values at runtime. The default constructor of VGMesh set them to 0, which is not what we want. Hopefully, there is an other constructor taking these value as parameters. We will use 3 channels to represent RGB images. For now, we will set the number of dimensions to 3, because the obj loader can only load meshes of dimension 3. We will change that value later. We also set the mesh's attribute on construction, but we will talk about this later.

  \snippet Vitelotte/tutorial/tutorial.cpp Create the mesh

  Now, we want to load a mesh defined in an `obj` file. In practice, VGMesh inherits PatateCommon::SurfaceMesh, a generic mesh representation copied from the [Surface_mesh](http://opensource.cit-ec.de/projects/surface_mesh) library (with some modifications). This class comes with an other template class PatateCommon::OBJReader that allow to read `obj` file. In practice, we can use it directly to load our VGMesh like this:

  \snippet Vitelotte/tutorial/tutorial.cpp Load a .obj

  You might wonder why we need to create a temporary reader object. This can have several use. One of them is that it allow to customize error reporting: by default it prints error on `stderr` and ignore warnings, but you can set your own callbacks. An other is that you can use the same reader for several files to avoid to reallocate some internal buffers. Other readers like the MVGReader use the same principle.

  We assume that the obj file we just loaded contains only vertices on the x-y plane, so we will discard the z coordinate. This result in a 2D image. This is simply done by changing the number of dimensions of the mesh with VGMesh::setNDims(). Note that this function is dumb: if you reduce the number of dimensions it will just discard extra coordinates, and if you increase it new coordinates _will not be initialized_.

  \snippet Vitelotte/tutorial/tutorial.cpp Convert the mesh in 2D


  \subsection vitelotte_user_manual_tutorial_vg_mesh_attributes_subsec Attributes

  To produce an image, we need to describe the color inside each face with some mathematical function. VGMesh is designed to be independent of the function used, so evaluating them is the job of some other class. VGMesh just need to store an arbitrary  set of parameters required to evaluate the function.

  As VGMesh inherits PatateCommon::SurfaceMesh, it allow to define arbitrary properties on vertices, edges, halfedges or faces. However this is not very practical so we provide a higher-level interface. VGMesh allow to choose a set of attributes describing which parameters we need per face. You can think of attributes as "attachment points" where you can define parameter on the faces. The currently available attributes are:

  - VGMesh::TO_VERTEX_VALUE: The color value at the target vertex of an halfedge.
  - VGMesh::FROM_VERTEX_VALUE: The color value at the source vertex of an halfedge.
  - VGMesh::EDGE_VALUE: The color value at the middle point of an halfedge.
  - VGMesh::EDGE_GRADIENT: The color _derivative_ in the normal direction of an halfedge.

  This may be a bit abstract, so there is an illustration:

  \image html vitelotte/vgmesh_attributes.svg "VGMesh's attributes."

  For example, with just the VGMesh::TO_VERTEX_VALUE attribute we have one color per vertex per face. This is enough to do linear color interpolation over each face.

  You can notice that there are two attributes per vertex. This allow to represent singularities, where two different colors are set on the same point, but in different directions.

  \image html vitelotte/singularities.png "The two extremities of the curve are singularities."

  With value attributes on the vertices and in the middle of each edge, we can do quadratic interpolation over each face. Our experience show that quadratic interpolation allow much better visual quality than linear interpolation, so unless said otherwise, all the illustrations are using it.

  The VGMesh::EDGE_GRADIENT is a bit more tricky. It is in fact unused for rendering: its purpose is to allow our FEM solver to use special elements for biharmonic diffusion. In practice, we will use Fraeijs de Veubeke's elements (FV) which happen to need exactly all the attributes of VGMesh.

  Attributes you want to use must be enabled. This way, unused attribute does not consume memory. This can be done with the method VGMesh::setAttribute or directly in the constructor. Remember our call to VGMesh's constructor ?

  \snippet Vitelotte/tutorial/tutorial.cpp Create the mesh

  The VGMesh::FV_FLAGS constant simply mean that we want to enable the attributes required for FV elements.


  \subsection vitelotte_user_manual_tutorial_vg_mesh_nodes_subsec Nodes

  So our VGMesh object has a whole set of attribute enabled. How do we access them ? Well, there is a level of indirection: we do not store a value (this is our term for color) directly for each attribute. Instead, we store a "node". Each node as a value, so this is almost the same. The difference is that a single node can be referenced by several attachment points. For instance, unless you want to represent a discontinuity, all attachments points around a vertex will likely point to the same node.

  This has several uses. Nodes can have an unknown value. This basically mean that we don't know yet which color should go here. Finding the value of such nodes is indeed the job of the solver. Now, having several attachment points pointing to the same node has a semantic meaning: it tells the solver that we want the same color at all these attachment points. Attaching unknowns and constraints nodes wisely is the key to control the solver. There is a typical example:

  \image html vitelotte/nodes.svg "A typical input to the solver. White dots are unknown nodes an orange ones are constraints."

  For simplicity, we don't show gradient nodes and we merge nodes on both sides of an edge if they are the same.

  We can define discontinuities simply by having a different node on each side of an edge. In the above example, the bottom left side is constrained while the top right is left unknown (The blue color comes from other constraints outside the boundary of the picture), but we could have constrained both sides or left them unknown too. When we want continuity, we simply link both side of the edge to the same nodes.

  What is going on if we use the same unknown node at two (or more) different places on the mesh ? Well, we call this _non-local constraints_. The current implementation of the solver supports it, but you need to pass a special flag to enable it as it as a small impact on performances.

  So, let's manipulate some node. By default, all attachment points are linked to an invalid node. This is not good: the solver will fail if the input mesh has invalid nodes, and the renderer will display an arbitrary color (likely black). We will start simple and create a node for each vertex and each edge, assign them random colors and link them to the corresponding attachment point. This gives us:

  \snippet Vitelotte/tutorial/tutorial.cpp Assign random colors

  There is two ways to access nodes. In the vertex loop, we use VGMesh::halfedgeNode and VGMesh::halfedgeOppositeNode. They take an halfedge and an attribute as parameter, which is practical in this case, particularly to set the opposite node. There is also more direct functions like VGMesh::edgeValueNode that we use in the edge loop. Such functions are defined for all the attributes.


  \subsection vitelotte_user_manual_tutorial_vg_mesh_output_subsec Writing mvg

  Well, let's output what we have now, we will look into the solver later. We developed a file format suitable to store VGMeshes that supports arbitrary attributes, unknown nodes and invalid nodes. It allow us to store meshes at different processing step, which is useful for debugging or to share intermediary results.

  We will not describe the format here, it has its own page. Just know that it is a simple text-based format inspired from the obj mesh format.

  Saving is straightforward and really similar to the code to read the mesh:

  \snippet Vitelotte/tutorial/tutorial.cpp Write the mesh

  We change the attributes to VGMesh::QUADRATIC_FLAGS to discard VGMesh::EDGE_GRADIENT which is useless for rendering. This allow to reduce slightly the output size. There is the result on a simple grid mesh:

  \image html vitelotte/tutorial_random.png "A regular grid with random colors."

  Well, that's ugly. We surely can do better using the solver.


  \subsection vitelotte_user_manual_tutorial_solver_subsec Using the solver

  The first thing to do to use the solver is to prepare the input. We likely want to set a few constraints and have something smooth everywhere else. As it may be annoying to do it by hand, we provide the VGMesh::finalize method that do this more or less automatically.

  Before we call VGMesh::finalize, we need to set a few constraints. Here, we will just set a constrained node for some random vertices and finalize will automatically propagate this node all around the constrained vertices. We could also set a different unknown node on each side of a path to insert a discontinuity.

  \snippet Vitelotte/tutorial/tutorial.cpp Color dots and finalize

  If we output the mesh now, we will have a black image with a few colored points. This is because our viewer shows unknown nodes as black.

  \image html vitelotte/tutorial_finalized.png "The mesh after finalization."

  Remember that the algorithm of finalize is not perfect and does not handle all tricky cases. For instance, it is not guaranteed to work for non-local constraints. See the documentation for details.


 */

 }
