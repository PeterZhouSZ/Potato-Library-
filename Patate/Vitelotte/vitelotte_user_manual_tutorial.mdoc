/*
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

namespace Vitelotte {

/*!
  \page vitelotte_user_manual_tutorial_page Vitelotte's Tutorial

  \section vitelotte_user_manual_tutorial_introduction_sec Introduction

  The Vitelotte library provides tools to manipulate mesh-based vector graphics. This is a way to represent images by segmenting the domain in cells, each of them being colored with some (simple) mathematical function, like a polynomial color interpolation. This representation allows smooth color gradients while retaining sharp edges, thus producing scalable images.

  There is basically two ways to get this kind of image. The first one is to vectorize a bitmap image. Vitelotte does not provide tools for this at the moment. The other one is to directly create such image. We provide a diffusion solver that can produce smooth color gradients from a sparse set of constraints for this.

  This tutorial will guide you through a simple program while introducing the main concepts of the library.

  At the end of the tutorial, you will have a program that sets random color constraints on an input mesh before computing the diffusion. It saves the result using our `mvg` file format (mvg stands for Mesh-based Vector Graphics), that can be visualized using the mvg_viewer example.

  \image html vitelotte/tutorial_solved.png "The final result."

  The complete source is available in `examples/Vitelotte/tutorial`.


  \section vitelotte_user_manual_tutorial_vg_mesh_sec VGMesh

  Vitelotte allow to manipulate vectorial images represented by meshes. More specifically, the image is partitioned in cells (we will call them "faces") and each cell use some mathematical function to describe its color. A simple example would be to a triangular mesh with a face-wise linear color interpolation of the color defined for each vertex. However, we are not limited to this: linear interpolation is often not enough to produce visually smooth results, so most of the time we will use quadratic interpolation.

  Vitelotte uses the class VGMesh to represent images. Like the rest of the Patate lib, VGMesh is templated. Its parameters are a scalar type, the number of dimensions \f$d\f$ of the mesh and the number of coefficients \f$n\f$ (aka. the number of channels). This mean that in practice VGMesh can represent a function \f$f: \Re^2 \rightarrow \Re^n\f$ embedded on a surface of dimension \f$d\f$. It may not be practical to have these values fixed at compile time, so we can also ask to be able to change them at runtime by using the symbolic value Dynamic. Let's use a typedef to ease our life:

  \snippet Vitelotte/tutorial/tutorial.cpp Declare the Mesh class

  As we set Dynamic as the number of dimensions and coefficients, we have to choose these values at runtime. The default constructor of VGMesh set them to 0, which is not what we want. Hopefully, there is an other constructor taking these value as parameters. We will use 3 channels to represent RGB images. For now, we will set the number of dimensions to 3, because the obj loader can only load meshes of dimension 3. We will change that value later. We also set the mesh's attribute on construction, but we will talk about this later.

  \snippet Vitelotte/tutorial/tutorial.cpp Create the mesh

  Now, we want to load a mesh defined in an `obj` file. In practice, VGMesh inherits PatateCommon::SurfaceMesh, a generic mesh representation copied from the [Surface_mesh](http://opensource.cit-ec.de/projects/surface_mesh) library (with some modifications). This class comes with an other template class PatateCommon::OBJReader that allow to read `obj` file. In practice, we can use it directly to load our VGMesh like this:

  \snippet Vitelotte/tutorial/tutorial.cpp Load a .obj

  You might wonder why we need to create a temporary reader object. This can have several use. One of them is that it allow to customize error reporting: by default it prints error on `stderr` and ignore warnings, but you can set your own callbacks. An other is that you can use the same reader for several files to avoid to reallocate some internal buffers. Other readers like the MVGReader use the same principle.

  We assume that the obj file we just loaded contains only vertices on the x-y plane, so we will discard the z coordinate. This result in a 2D image. This is simply done by changing the number of dimensions of the mesh with VGMesh::setNDims(). Note that this function is dumb: if you reduce the number of dimensions it will just discard extra coordinates, and if you increase it new coordinates _will not be initialized_.

  \snippet Vitelotte/tutorial/tutorial.cpp Convert the mesh in 2D


  \subsection vitelotte_user_manual_tutorial_vg_mesh_attributes_subsec Attributes

  To produce an image, we need to describe the color inside each face with some mathematical function. VGMesh is designed to be independent of the function used, so evaluating them is the job of some other class. VGMesh just need to store an arbitrary  set of parameters required to evaluate the function.

  As VGMesh inherits PatateCommon::SurfaceMesh, it allow to define arbitrary properties on vertices, edges, halfedges or faces. However this is not very practical so we provide a higher-level interface. VGMesh allow to choose a set of attributes describing which parameters we need per face. You can think of attributes as "attachment points" where you can define parameter on the faces. The currently available attributes are:

  - VGMesh::TO_VERTEX_VALUE: The color value at the target vertex of an halfedge.
  - VGMesh::FROM_VERTEX_VALUE: The color value at the source vertex of an halfedge.
  - VGMesh::EDGE_VALUE: The color value at the middle point of an halfedge.
  - VGMesh::EDGE_GRADIENT: The color _derivative_ in the normal direction of an halfedge.

  This may be a bit abstract, so there is an illustration:

  \image html vitelotte/vgmesh_attributes.svg "VGMesh's attributes."

  For example, with just the VGMesh::TO_VERTEX_VALUE attribute we have one color per vertex per face. This is enough to do linear color interpolation over each face.

  You can notice that there are two attributes per vertex. This allow to represent singularities, where two different colors are set on the same point, but in different directions.

  \image html vitelotte/singularities.png "The two extremities of the curve are singularities."

  With value attributes on the vertices and in the middle of each edge, we can do quadratic interpolation over each face. Our experience show that quadratic interpolation allow much better visual quality than linear interpolation, so unless said otherwise, all the illustrations are using it.

  The VGMesh::EDGE_GRADIENT is a bit more tricky. It is in fact unused for rendering: its purpose is to allow our FEM solver to use special elements for biharmonic diffusion. In practice, we will use Fraeijs de Veubeke's elements (FV) which happen to need exactly all the attributes of VGMesh.

  Attributes you want to use must be enabled. This way, unused attribute does not consume memory. This can be done with the method VGMesh::setAttribute or directly in the constructor. Remember our call to VGMesh's constructor ?

  \snippet Vitelotte/tutorial/tutorial.cpp Create the mesh

  The VGMesh::FV_FLAGS constant simply mean that we want to enable the attributes required for FV elements.


  \subsection vitelotte_user_manual_tutorial_vg_mesh_nodes_subsec Nodes

  So our VGMesh object has a whole set of attribute enabled. How do we access them ? Well, there is a level of indirection: we do not store a value (this is our term for color) directly for each attribute. Instead, we store a "node". Each node as a value, so this is almost the same. The difference is that a single node can be referenced by several attachment points. For instance, unless you want to represent a discontinuity, all attachments points around a vertex will likely point to the same node.

  This has several uses. Nodes can have an unknown value. This basically mean that we don't know yet which color should go here. Finding the value of such nodes is indeed the job of the solver. Now, having several attachment points pointing to the same node has a semantic meaning: it tells the solver that we want the same color at all these attachment points. Attaching unknowns and constraints nodes wisely is the key to control the solver. There is a typical example:

  \image html vitelotte/nodes.svg "A typical input to the solver. White dots are unknown nodes an orange ones are constraints."

  For simplicity, we don't show gradient nodes and we merge nodes on both sides of an edge if they are the same.

  We can define discontinuities simply by having a different node on each side of an edge. In the above example, the bottom left side is constrained while the top right is left unknown (The blue color comes from other constraints outside the boundary of the picture), but we could have constrained both sides or left them unknown too. When we want continuity, we simply link both side of the edge to the same nodes.

  What is going on if we use the same unknown node at two (or more) different places on the mesh ? Well, we call this _non-local constraints_. The current implementation of the solver supports it, but you need to pass a special flag to enable it as it as a small impact on performances.

  So, let's manipulate some node. By default, all attachment points are linked to an invalid node. This is not good: the solver will fail if the input mesh has invalid nodes, and the renderer will display an arbitrary color (likely black). We will start simple and create a node for each vertex and each edge, assign them random colors and link them to the corresponding attachment point. This gives us:

  \snippet Vitelotte/tutorial/tutorial.cpp Assign random colors

  There is two ways to access nodes. In the vertex loop, we use VGMesh::halfedgeNode and VGMesh::halfedgeOppositeNode. They take an halfedge and an attribute as parameter, which is practical in this case, particularly to set the opposite node. There is also more direct functions like VGMesh::edgeValueNode that we use in the edge loop. Such functions are defined for all the attributes.


  \subsection vitelotte_user_manual_tutorial_vg_mesh_output_subsec Writing mvg

  Well, let's output what we have now, we will look into the solver later. We developed a file format suitable to store VGMeshes that supports arbitrary attributes, unknown nodes and invalid nodes. It allow us to store meshes at different processing step, which is useful for debugging or to share intermediary results.

  We will not describe the format here, it has its own page. Just know that it is a simple text-based format inspired from the obj mesh format.

  Saving is straightforward and really similar to the code to read the mesh:

  \snippet Vitelotte/tutorial/tutorial.cpp Write the mesh

  We change the attributes to VGMesh::QUADRATIC_FLAGS to discard VGMesh::EDGE_GRADIENT which is useless for rendering. This allow to reduce slightly the output size. There is the result on a simple grid mesh:

  \image html vitelotte/tutorial_random.png "A regular grid with random colors."

  Well, that's ugly. We surely can do better using the solver.


  \subsection vitelotte_user_manual_tutorial_solver_subsec Using the solver

  The first thing to do to use the solver is to prepare the input. We likely want to set a few constraints and have something smooth everywhere else. As it may be annoying to do it by hand, we provide the VGMesh::finalize method that do this more or less automatically.

  Before we call VGMesh::finalize, we need to set a few constraints. Here, we will just set a constrained node for some random vertices and finalize will automatically propagate this node all around the constrained vertices. We could also set a different unknown node on each side of a path to insert a discontinuity.

  \snippet Vitelotte/tutorial/tutorial.cpp Color dots and finalize

  If we output the mesh now, we will have a black image with a few colored points. This is because our viewer shows unknown nodes as black.

  \image html vitelotte/tutorial_finalized.png "The mesh after finalization."

  Remember that the algorithm of finalize is not perfect and does not handle all tricky cases. For instance, it is not guaranteed to work for non-local constraints. See the documentation for details.

  \todo link to doc

  Now we are ready to solve the diffusion. First, we need to create our solver object:

  \snippet Vitelotte/tutorial/tutorial.cpp Create the solver

  The FemSolver class is parametrized with the mesh and an ElementBuilder. The element builder describe how to build the stiffness matrix and so varies in function of the element type we want to use. FVElementBuilder is the class to solve the diffusion with FV elements. This class does not support singular elements directly, so we decorate it with the SingularElementDecorator. This may seems complicated, but in practice we always do this, so there is no need to worry about the details (unless you want to implement your own element type).

  Then, the FemSolver is simply parametrized with the mesh type and the element builder. It takes the mesh to work with in parameter. Solving is now straightforward:

  \snippet Vitelotte/tutorial/tutorial.cpp Solve the diffusion

  Why is there two steps ? FemSolver::build construct the matrix and invert it. It is time consuming but does not depend on the right hand side of the problem: the actual values of the constraint. This mean that you don't need to call this costly step if you only modify the values. However, if there is a change in geometry, in connectivity (including nodes) or in the type of some node (switching to unknown or constraint), then you _need_ to call it. In case of doubt, just call it to be sure.

  FemSolver::solve does what its name state. This will replace all the unknown nodes by constraints one, thus producing the final image. Note that the solver may fail, either because the input mesh is invalid or because the problem is numerically unstable, so check for errors.

  \image html vitelotte/tutorial_solved.png "The final result."

  This is it ! If you want to dive further in Vitelotte, you can read the rest of this manual or browse the references.

 */

 }
