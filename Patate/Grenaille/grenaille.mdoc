/*!

  \brief Fit and analyze point-clouds efficiently.
    
  For a first contact, the best place is to have a look at the 
  \ref grenaille_tutorial1 and at the Grenaille::Concept page that presents 
  concepts defining the Grenaille API. 
  
  These concepts are implemented in many ways to fit different kind of 
  primitives on various data. The above list of available features gives a direct
  access to their documentation: mathematical overview, related papers, and API.
  
 */
namespace Grenaille
{ 
  /*!
    \brief Main concepts used in Grenaille
    
    The Grenaille API is driven by five concepts, one defining samples  
    structure (pointConcept), two to define how to weight
    neighbor samples (WeightKernelConcept and WeightFuncConcept), and two
    other to perform the fitting procedure and additional computations 
    (FittingProcedureConcept and FittingExtensionConcept).
    
    The various implementations of these concepts are mixed through 
    specializations of the Basket class:
    \code
    typedef 
    Basket <PointImpl,              // Implementation of PointConcept
    
            WeightFuncImpl,         // Implementation of WeightFuncConcept (could use WeightKernelConcept)
            
            FittingProcedureImpl,   // Implementation of FittingProcedureConcept
            
            FittingExtensionImpl1,  // 
            FittingExtensionImpl2,  // Implementations of FittingExtensionConcept
            ... ,                   //
            FittingExtensionImpln   //
            
            > myFit;                // Final structure to fit and extend a primitive over weighted samples
    \endcode
    
    \see \ref grenaille_tutorial1 for a complete how-to.
    \see Related pages listed below defining concepts API:
  */
  namespace Concept{
    /*!
      \brief Defines procedure to fit a primitive on samples
      
      The typical usage of this approach is:
      \code    
        typedef Basket<MyPointStructure,MyWeightingFunction,MyFittingProcedure> Fit;
        MyWeightingFunction w ( some_parameters );

        // Create a fit object      
        Fit fit;
        
        // init the internal state with respect to the reference position
        fit.init( referencePosition );
        
        // set the weighting function. Has no influence of the other internals
        fit.setWeightFunc( w );
        
        foreach neighbors of referencePosition
          fit.addNeighbor(neighbor);
          
        fit.finalize();
        
        // use the fit
        // ... 
      \endcode
      
      \warning This class not really exist in the source code. It is only provided
      to describe the Concept that have to implement the fitting 
      procedures.    
     */
    template < class DataPoint, class _WFunctor, typename T = void >
    class FittingProcedureConcept {
      public:
      /**************************************************************************/
      /* Initialization                                                         */
      /**************************************************************************/
     /*! 
        \brief Init the WeightFunc, without changing the other internal states
        \warning Must be called be for any computation 
      */
      void setWeightFunc (const WFunctor& w){};
      
      /*!
        \brief Set the evaluation position and reset the internal states. 
        \warning Must be called be for any computation
      */
      void init (const VectorType& evalPos){};
      

      /**************************************************************************/
      /* Processing                                                             */
      /**************************************************************************/
      /*!
        \brief Add a neighbor to perform the fit 
      */
      void addNeighbor(const DataPoint &nei){};
      
      /*!
        \brief Finalize the fitting procedure    
        \warning Must be called be for any use of the fitting output
      */
      void finalize (){};    
    };
    
    /*!
      \brief Defines procedure to extend a fit to compute additional informations
      
      The typical usage of this approach is:
      \code
        typedef Basket<MyPointStructure,MyWeightingFunction,MyFittingProcedure, MyExtension1, MyExtension2, ...> ExtendedFit;
        MyWeightingFunction w ( some_parameters );

        // Create a fit object      
        ExtendedFit extFit;
        
        // init the internal state with respect to the reference position
        extFit.init( referencePosition );
        
        // set the weighting function. Has no influence of the other internals
        extFit.setWeightFunc( w );
        
        foreach neighbors of referencePosition
          extFit.addNeighbor(neighbor);
          
        extFit.finalize();
        
        // use the result of the fit and its extensions
        // ... 
      \endcode
      
      Any of the functions defined in an extension must first call the Base class:
      \code    
        MULTIARCH inline void init (const VectorType& evalPos){
          Base::init(evalPos);        
          //extended stuff
        };
      \endcode
      
      \warning This class not really exist in the source code. It is only provided
      to describe the Concept that have to implement the fitting 
      extensions.    
     */
    template < class DataPoint, class _WFunctor, typename T = void >
    class FittingExtensionConcept {
      public:
      /**************************************************************************/
      /* Initialization                                                         */
      /**************************************************************************/
      /*! \see FittingProcedureConcept::setWeightFunc */
      void setWeightFunc (const WFunctor& w){};
      
      /*! \see FittingProcedureConcept::init */
      void init (const VectorType& evalPos){};
      

      /**************************************************************************/
      /* Processing                                                             */
      /**************************************************************************/
      /*! \see FittingProcedureConcept::addNeighbor */
      void addNeighbor(const DataPoint &nei){};
      
      /*! \see FittingProcedureConcept::finalize */
      void finalize (){};    
    };
    
    
    /*!
      \brief This base class defines the weighting kernel concept
    */
    template <typename _Scalar>
    class WeightKernelConcept{
    public:
      typedef _Scalar Scalar;

      //! \brief Apply the weighting kernel to the scalar value \f$f(x)\f$
      MULTIARCH inline Scalar f  (const Scalar& x) const {}
      //! \brief Apply the first derivative of the weighting kernel to the scalar value \f$f'(x)\f$
      MULTIARCH inline Scalar df (const Scalar& x) const {}
      //! \brief Apply the second derivative of the weighting kernel to the scalar value \f$f''(x)\f$
      MULTIARCH inline Scalar ddf(const Scalar& x) const {}
    };// class WeightKernelConcept
    
    
    /*!
      \brief Weighting function concept
    */
    template <class Point>
    class WeightFuncConcept {

    public:        
      typedef typename DataPoint::Scalar Scalar;
      typedef typename DataPoint::VectorType VectorType;
        
      /*! \brief Apply the weight function to a query. */
      MULTIARCH inline Scalar w(const VectorType& relativeQuery, 
			        const DataPoint&  attributes) const {}   
         
      /*! \brief Apply the weight function differenciated in space to a query. */
      MULTIARCH inline VectorType spacedw(const VectorType& relativeQuery, 
				      const DataPoint&  attributes) const {}   
         
      /*! \brief Apply the weight function differenciated in scale to a query. */
      MULTIARCH inline Scalar scaledw(const VectorType& relativeQuery, 
				      const DataPoint&  attributes) const {}

      /*! \brief Read access to the evaluation scale */
      MULTIARCH inline Scalar evalScale() const {}   
    };// class WeightFuncConcept
    
    /*!
      \brief Definition of the sample structure.
      
      This is the minimalist point definition. Additional features might be 
      required depending of the Basket definition, as listed in the 
      documentation pages of the involved weight function, 
      fitting procedure and fitting extension.
      
      Grenaille do not provide implementation for this concept, in order to let
      users adapt it to their own data structure. However, the following 
      implementation can be used as starting point for many 3D applications:
      \code
      class MyPoint{
      public:
        enum {Dim = 3};
        typedef float Scalar;
        typedef Eigen::Matrix<Scalar, Dim, 1> VectorType;

        MULTIARCH inline MyPoint(const VectorType &pos = VectorType::Zero())
          : _pos(pos) {}
          
        MULTIARCH inline const VectorType& pos() const { return _pos; }  
        MULTIARCH inline       VectorType& pos()       { return _pos; }  

      private:
        VectorType _pos;
      };
      \endcode
     */
    class PointConcept{
      public:
        /*! \brief Defines the ambient space dimension, 3 in this example */
        enum {Dim = 3}; 
        /*! \brief Defines the type used ton encode scalar values */
        typedef float Scalar;
        /*! \brief Defines type used ton encode vector values */
        typedef Eigen::Matrix<Scalar, Dim, 1> VectorType;

        /*! \brief Default constructor */
        MULTIARCH inline PointConcept(){}
          
        /*! \brief Read access to the position property */
        MULTIARCH inline const VectorType& pos() const {}  
        /*! \brief Write access to the position property */
        MULTIARCH inline       VectorType& pos()       {}  
      }; //class PointConcept
  
  } // End namespace Concept
} // End namespace Grenaille
