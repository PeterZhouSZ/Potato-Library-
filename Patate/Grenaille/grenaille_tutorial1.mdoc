/*!
  \page grenaille_tutorial1 Grenaille first tutorial  
  
  This tutorial explains basics of Grenaille. The complete source-code is
  available at \ref cpp/grenaille_basic_cpu.cpp.
  
  <h3>Table of Content</h3>
  - \ref grenaille_tutorial1_section_define
    - \ref grenaille_tutorial1_subsection_define_samples
    - \ref grenaille_tutorial1_subsection_define_fit
  - \ref grenaille_tutorial1_section_fitting
  - \ref grenaille_tutorial1_section_access
    - \ref grenaille_tutorial1_section_access_field
    - \ref grenaille_tutorial1_section_access_sphere
    - \ref grenaille_tutorial1_section_access_other

  \section grenaille_tutorial1_section_define Defining samples and processing classes
  The first step needed to use Grenaille is to define how samples are represented
  and indicates how Grenaille can access them for processing, with respect to 
  the fitted primitive and the potential extensions required.
  
  A strength of Grenaille is to define all these structures at compile time to
  generate optimized code for fast evaluation at runtime. The only job you have
  to do is defining types and classes that might be used by Grenaille to process
  your data. 
  
  
    
  \subsection grenaille_tutorial1_subsection_define_samples Samples
  The description of how sample points are represented has to be done by the 
  user in order to make Grenaille easy to integrate in any existing application.
  Indeed, with this approach it is not required to convert internal data format
  from the application to Grenaille, but only to indicates how to access to
  existing data.  
  
  The class Grenaille::Concept::PointConcept defines the interface that have to 
  be implemented. For this example, we want to fit a Grenaille::AlgebraicSphere 
  over point equipped with normals using Grenaille::OrientedSphereFit, so we 
  have to add a normal vector and the associated getters/setters. It is also
  necessary to define a Matrix Type, requested by Grenaille::AlgebraicSphere. 

  The final class is defined as:
  \code
  using namespace Grenaille;
  
  // This class defines the input data format
  class MyPoint{
  public:
    enum {Dim = 3};
    typedef double Scalar;
    typedef Eigen::Matrix<Scalar, Dim, 1>   VectorType;
    typedef Eigen::Matrix<Scalar, Dim, Dim> MatrixType; // Type needed by Grenaille::AlgebraicSphere

    MULTIARCH inline MyPoint(const VectorType &pos    = VectorType::Zero(), 
		   const VectorType& normal = VectorType::Zero())
      : _pos(pos), _normal(normal) {}
      
    MULTIARCH inline const VectorType& pos()    const { return _pos; }  
    MULTIARCH inline const VectorType& normal() const { return _normal; }

    MULTIARCH inline VectorType& pos()    { return _pos; }  
    MULTIARCH inline VectorType& normal() { return _normal; }

    static inline MyPoint Random() {
      VectorType n = VectorType::Random().normalized();
      VectorType p = n * Eigen::internal::random<Scalar>(0.9,1.1);
      return MyPoint (p, (n + VectorType::Random()*0.1).normalized());
    };

  private:
    VectorType _pos, _normal;
  };
  \endcode
  Note the <CODE>Random</CODE> method to initialize samples and generates a 
  noisy sphere. 
  
  
  We can also define helper <CODE>typedef</CODE> for <CODE>Scalar</CODE> and 
  <CODE>Vector</CODE> types: 
  \code
  typedef MyPoint::Scalar Scalar;
  typedef MyPoint::VectorType VectorType;
  \endcode
  
  
  
  
  
  \subsection grenaille_tutorial1_subsection_define_fit Fitting procedure
  Their is basically two Types that must be defined to specialize the fitting
  procedure.  
  
  The first one defines how samples will contribute to the fit, through a given
  weighting function. In this example, samples are weighted by considering their
  distance to an evaluation point in order to collect of a ball neighborhood,
  using Grenaille::DistWeightFunc. This weighting function could be specialized
  by any arbitrary 1D WeighKernel that is applied to the euclidean distance (no 
  mater the dimension number of the ambient space). In this example we use a
  standard bisquare kernel defined in Grenaille::SmoothWeightKernel:
  \code
  typedef DistWeightFunc<MyPoint,SmoothWeightKernel<Scalar> > WeightFunc; 
  \endcode
  
  The last but not least type definition combines the sample description, the 
  weighting function with a fitting procedure and its associated extensions.
  This is achieved by filling a Grenaille::Basket. In this example a
  Grenaille::AlgebraicSphere is fitted using a Grenaille::OrientedSphereFit 
  procedure. Note that the primitive is implicitly defined by the fitting 
  procedure, that's why it doesn't appear in the Basket). A Growing Least Square
  reparametrization is also applied by Grenaille::GLSParam.
  
  \code
  typedef Basket<MyPoint,WeightFunc,OrientedSphereFit, GLSParam> Fit1;  
  \endcode
  
  
    
  
  \section grenaille_tutorial1_section_fitting Processing

  Once types are now defined, the main part of the job is done. We can now
  create an object, assign it an instance of the weighting function, and
  set the evaluation position.
  \code
  // Create the previously defined fitting procedure
  Fit1 fit;
  
  // Set a weighting function instance
  fit.setWeightFunc(WeightFunc(tmax));
  
  // Set the evaluation position
  fit.init(p);
  \endcode
  
  Neighbors are then added sequentially to compute the fit. In this example we
  iterate over all the elements stored in an array, and let the weighting 
  function filtering points that are outside of the neighborhood ball. In 
  practice the computation may change with respect to the Basket definition.
  
  \code
  // Iterate over samples and fit the primitive
  for(vector<MyPoint>::iterator it = vecs.begin(); it != vecs.end(); it++)
    fit.addNeighbor(*it); 
    
  //finalize fitting 
  fit.finalize();
  \endcode
  
  
  
  \section grenaille_tutorial1_section_access Playing with computed values  
  Since the primitive has been adjusted, it is now possible to access to 
  various computed fields.
  
  \subsection grenaille_tutorial1_section_access_field Scalar field  
  Access to properties of the fitted scalar-field, defined in Grenaille::AlgebraicSphere :
  \code
  cout << "Value of the scalar field at the initial point: " 
       << p.transpose() 
       << " is equal to " << fit.potential(p)
       << endl;
       
  cout << "It's gradient at this place is equal to: "
       << fit.primitiveGradient(p).transpose()
       << endl;
  \endcode  
  generates the following output  
  \code
  Value of the scalar field at the initial point: 0 0 0 is equal to -0.501162
  It's gradient at this place is equal to:   0.00016028  0.000178782 -0.000384989
  \endcode
  
  \subsection grenaille_tutorial1_section_access_sphere Sphere
  Access to properties of the fitted sphere (0-isosurface of the fitted scalar field), also defined in Grenaille::AlgebraicSphere :
  \code
  cout << "Center: [" << fit.center().transpose() << "] ;  radius: " << fit.radius() << endl;
  \endcode
  to get
  \code 
  Center: [-0.000160652 -0.000179197  0.000385884] ;  radius: 1.00232
  \endcode
  
  You can also access to the Growing Least Square reparametrization defined in Grenaille::GLSParam :
  \code
  cout << "Fitted Sphere: " << endl
       << "\t Tau  : "      << fit.tau()             << endl
       << "\t Eta  : "      << fit.eta().transpose() << endl
       << "\t Kappa: "      << fit.kappa()           << endl;
  \endcode
  to get
  \code 
	Fitted Sphere: 
	  Tau  : -0.501162
	  Eta  :   0.35325  0.394028 -0.848502
	  Kappa: 0.997682 
  \endcode
    
  \subsection grenaille_tutorial1_section_access_other Other methods
  Grenaille::AlgebraicSphere also gives access to a method to project a point on the fitted sphere:
  \code
  cout << "The initial point " << p.transpose()              << endl
       << "Is projected at   " << fit.project(p).transpose() << endl;
  \endcode
  that will generate:
  \code
  The initial point 0 0 0
  Is projected at    0.353911  0.394765 -0.850088
  \endcode
 */
