namespace Grenaille{

/*!
  \page grenaille_tutorial2 Grenaille curvature tutorial
  
  This tutorial presents how to compute curvature values from the various fitting
  procedures and extensions available in Grenaille.
  
  \section grenaille_tutorial2_section_sphere Sphere fitting
  \subsection grenaille_tutorial2_section_sphere_subsection_meancurvature Mean Curvature
  A fast approximation of the mean curvature is provided by GLSParam::kappa():
  \code
  typedef Basket<MyPoint, WeightFunc, OrientedSphereFit, // Sphere fitting
                                      GLSParam> Fit;     // GLS reparametrization
  
  Fit fit;
  // Fit primitive
  // ... 
  
  // Get mean curvature
  Scalar curvature = fit.kappa();
  \endcode
  
  It can also be extracted by analysing the spatial derivatives of fitted normals, 
  provided by GLSDer::deta(). Note that the computation cost is more important 
  in this case.
  \code
  typedef Basket<MyPoint, WeightFunc, OrientedSphereFit,    // Sphere fitting
                                    GLSParam,               // GLS reparametrization
                                    OrientedSphereSpaceDer, // Spatial derivatives 
                                    GLSDer > Fit;           // GLS differentiation                                    
  
  Fit fit;
  // Fit primitive
  // ... 
  
  // Mean curvature values is given by half of the trace of the jacobian matrix
  MatrixType jacobian = fit.deta();  
  cout << " Mean curvature: " << 0.5 * jacobian.trace() << endl;
  \endcode
    
  \subsection grenaille_tutorial2_section_sphere_subsection_principalcurvatures Principal Curvatures
  Principal curvature values and the associated directions can be computed by 
  an eigen decomposition of the spatial derivatives of eta, provided by 
  GLSDer::deta():
  \code
  typedef Basket<MyPoint, WeightFunc, OrientedSphereFit,    // Sphere fitting
                                    GLSParam,               // GLS reparametrization
                                    OrientedSphereSpaceDer, // Spatial derivatives 
                                    GLSDer > Fit;           // GLS differentiation   
  
  Fit fit;
  // Fit primitive
  // ... 
  
  // Get derivatives
  MatrixType jacobian = fit.deta();
  cout << "eta jacobian: \n" << jacobian << endl;
  
  // Perform eigen decomposition
  Eigen::SelfAdjointEigenSolver<MatrixType> eig(jacobian.transpose() * jacobian);
  
  // Principal curvature values are the two largest eigenvalues:
  Scalar k1 = sqrt(eig.eigenvalues()(2)); //need sqrt because we solve eigen
  Scalar k2 = sqrt(eig.eigenvalues()(1)); //decomposition of JT * J
  
  // And the associated direction by the two last eigenvectors
  cout << " eigvec:\n" << eig.eigenvectors() << endl;
  VectorType v1 = eig.eigenvectors().col(2);
  VectorType v2 = eig.eigenvectors().col(1);
  \endcode
  
 \warning SelfAdjointEigenSolver is partially supported by eigen-nvcc, so you may
  need to use computeDirect to perform eigen decomposition in cuda kernels:
  \code
  Eigen::SelfAdjointEigenSolver<MatrixType> eig;
  eig.computeDirect((jacobian.transpose() * jacobian);  
  \endcode
  
  \note The SelfAdjointEigenSolver needs symmetric matrices. If you want 
  signed principal curvatures, you may use another Eigen solver. See 
  <a href="http://eigen.tuxfamily.org/dox/group__TopicLinearAlgebraDecompositions.html"
  target="_blank">Eigen documentation</a> for further details.
 */
}
